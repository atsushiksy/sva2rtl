#! /usr/bin/perl
#
#  parse yacc pre file and produce various header files.
#
#  Author: Atsushi Kasuya
#
#   Copyright (C) 2011 Atsushi Kasuya

$incomment = 0 ;
$inbody = 0 ;
$current_num = 0 ;
$max_num = 0 ;

open ( TMPF, ">SystemVerilog.y.prep" ) ;
print TMPF "/******************************************************/\n" ;
print TMPF "/* Auto-generated by parse_yacc.pl                    */\n" ;
print TMPF "/*   DO NOT EDIT DIRECTLY!                            */\n" ;
print TMPF "/******************************************************/\n" ;

while( <> ) {
  chop ;
  $line = $_ ;
  
  if( $line =~ /^\s*\%token \<\S+\> (\w+)/ ) {
    $token = $1 ;
    #print "Token: $1\n" ;
    $primitive{$token} = 1 ;
  }
  
  if( $line =~ /^\s*%%/ ) {
    $inbody = 1 ;
    #print "start!! \n" ;
  }
  elsif( $line =~ /^\s*\/\// ) {
    # comment line
    # print "\n" ;
  }
  elsif( $line =~ /^\s*#/ ) {
    ## skip # comment
  }
  elsif( !$inbody ) {
    ## skip non syntax area
  }
  elsif( $line =~ /^\s*\/\*/ ) {
    $rest = $' ;
    if( $rest =~ /\*\// ) {
      $incomment = 0 ;
    }
    else {
      $incomment = 1 ;
      #print "incomment! \n" ;
    }
  }
  elsif( $line =~ /\*\// ) {
    $incomment = 0 ;
    #print "outcomment! \n" ;
  }
  elsif( !$incomment ) {
    if( $line =~ /^\s*(\w+):/ ) {
      #print "def:  $1\n" ;
      $currentword = $1 ;
      $defined{$1} = 1 ;
      $current_num = 0 ;
      $action_defined = 0 ;
      if( $nonterminal{$1} ) {
        $nonterminal{$1} = 2 ;
      }
    }
    elsif( $line =~ /^\s*\<\<(\w+)\>\>/ ) {
      $action_defined = 1 ;
      #print "$1\n" ;
    }
    elsif ( $line =~ /^\s*\|/ ) {
      if( $action_defined == 0 ) {
        if( $current_num ) {
          print TMPF "  <<Node_$current_num>>\n" ;
          if( $current_num > $max_num ) {
            $max_num = $current_num ;
	  }
	}
        else {
          print TMPF "  <<DDeqNULL>>\n" ;
        }
      }
      $action_defined = 0 ;
      $current_num = 0 ;
    }
    elsif( $line =~ '^\s*\;' ) {
      if( $action_defined == 0 ) {
        if( $current_num ) {
          print TMPF "  <<Node_$current_num>>\n" ;
          if( $current_num > $max_num ) {
            $max_num = $current_num ;
	  }
	}
        else {
          print TMPF "  <<DDeqNULL>>\n" ;
        }
      }
      $action_defined = 0 ;
      $current_num = 0 ;
    }
    else {
      $rest = $line ;
      while( $rest =~ /^\s*(\S+)/ ) {
        $term = $1 ;
        $rest = $' ;
        if( $term =~ /^\'/ ) {
          $current_num++ ;
          if( $term =~ /^\'(\w+)\'/ ) {
            $keywords{$1} = 1 ;
          }
          elsif( $term =~ /^\'(\S)\'/ ) {
            $singleops{$1} = 1 ;
          }
          elsif( $term =~ /^\'(\S\S+)\'/ ) {
            $operators{$1} = 1 ;
	  }
	  else {
	    print "$currentword key ?? $term\n" ;
	    print "$line \n" ;
	  }
          #print "key: $term \n"
        }
        else {
          $current_num++ ;      
          #print "get: $1\n" ;
          $nonterminal{$term} = 1 ;
          if( $defined{$term} ) {
            $nonterminal{$term} = 2 ;
          }
        }
      }
    }
  }
  print TMPF "$line \n" ;

}

close TMPF ;

open ( OPRTR, "<SystemVerilogOperators.data" ) ;
while( <OPRTR> ) {
  $line = $_ ;
  if( $line =~ /^\s*(\S+)\s+(\w+)/ ) {
    $opname{$1} = $2 ;
    #print "$1  $2\n" ;
  }
}
close (OPRTR) ;

open ( TYPEF, ">SV_token_table.h" ) ;
open ( KEYTB, ">SV_keywords.data" ) ;
foreach $nm (keys %keywords) {
  print TYPEF "\%token <sv_node> SV_$nm\n" ;
  print KEYTB "$nm  SV_$nm\n" ;
}

foreach $nm (keys %operators) {
  $tkn = $opname{$nm} ;
  if( $tkn ) {
    print TYPEF "\%token <sv_node> $tkn\n" ;
    print KEYTB "$nm  $tkn\n" ;
  }
  else {
    print "Undef $nm\n"
  }
}
foreach $nm (keys %singleops ) {
  if( $nm =~ /\\/ ) {
    $nm = "\\\\" ;
  }
  print TYPEF "\%token <sv_node> \'$nm\'\n"
}

foreach $nm (keys %defined) {
  print TYPEF "\%type <sv_node> $nm \n" ;
}

close( TYPEF ) ;
close( KEYTB ) ;

open( KWDT, ">SystemVerilog_keyword_table.h" ) ;

print KWDT "static keyword_entry keyword_table[] = {\n" ;

foreach $nm (keys %keywords) {
  print KWDT "  { \"$nm\", SV_$nm },\n" ;
}
print KWDT "{ NULL, 0 } } ;\n" ;
close(KWDT) ;

open( LEXOP, ">SystemVerilog_operator_lex.h" ) ;
foreach $nm (keys %operators) {
  $tkn = $opname{$nm} ;
  if( $tkn ) {
    print LEXOP "\"$nm\"  {\n" ;
    print LEXOP "  yylval.sv_node = ALLOC_SV_NODE ;\n" ;
    print LEXOP "  yylval.sv_node->linenum = lex_line_num ;\n" ;
    print LEXOP "  yylval.sv_node->filename = input_file_name ;\n" ;
    print LEXOP "  yylval.sv_node->name = \n" ;
    print LEXOP "    (char *)calloc( strlen(yytext)+10, sizeof(char) ) ;\n" ;
    print LEXOP "  strcat( yylval.sv_node->name, yytext ) ;\n" ;
    print LEXOP "  yylval.sv_node->type = $tkn ;\n" ;
    print LEXOP "  return $tkn ;\n" ;
    print LEXOP "}\n" ;
  }
}

close( LEXOP ) ;

foreach $nm (keys %nonterminal)
{
  if( $nonterminal{$nm} == 1 ) {
    if( $defined{$nm} ) {
      $nonterminal{$nm} = 2 ;
    }
    else {
      if( $primitive{$nm} ) {
      
      }
      else{
        print "Not defined $nm\n" ;
      }
    }
  }
  if( $nonterminal{$nm} == 2 ) {
     ## print "nm: $nm\n" ;
  }  
    
}
print "Max $max_num\n" ;
